<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Setup · BridgeSDEInference.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>BridgeSDEInference.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../overview/">Workflow</a></li><li><a class="toctext" href="../model_definition/">Defining a diffusion</a></li><li><a class="toctext" href="../generate_data/">Data generation</a></li><li class="current"><a class="toctext" href>Setup</a><ul class="internal"><li><a class="toctext" href="#Defining-the-processes-1">Defining the processes</a></li><li><a class="toctext" href="#Observations-1">Observations</a></li><li><a class="toctext" href="#Imputation-grid-1">Imputation grid</a></li><li><a class="toctext" href="#Transition-kernels-1">Transition kernels</a></li><li><a class="toctext" href="#Priors-1">Priors</a></li><li><a class="toctext" href="#Blocking-1">Blocking</a></li><li><a class="toctext" href="#ODE-solvers-1">ODE solvers</a></li><li><a class="toctext" href="#MCMC-parameters-1">MCMC parameters</a></li><li><a class="toctext" href="#Initialisation-of-internal-containers-1">Initialisation of internal containers</a></li></ul></li><li><a class="toctext" href="../run/">Running the sampler</a></li><li><a class="toctext" href="../query/">Querying the results</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/fitzhugh_nagumo/">FitzHugh-Nagumo model</a></li><li><a class="toctext" href="../../examples/jansen_rit/">Jansen-Rit model</a></li><li><a class="toctext" href="../../examples/lorenz63/">Lorenz63 system</a></li><li><a class="toctext" href="../../examples/lorenz96/">Lorenz96 system</a></li><li><a class="toctext" href="../../examples/prokaryote/">Prokaryotic autoregulatory gene network</a></li><li><a class="toctext" href="../../examples/sine/">Sine diffusion</a></li></ul></li><li><a class="toctext" href="../../vis/visualisation/">Visualisation tools</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorial</li><li><a href>Setup</a></li></ul><a class="edit-page" href="https://github.com/mmider/BridgeSDEInference.jl/blob/master/docs/src/man/setup.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Setup</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Defining-the-observational-scheme-and-parameters-of-the-Markov-chain-1" href="#Defining-the-observational-scheme-and-parameters-of-the-Markov-chain-1">Defining the observational scheme and parameters of the Markov chain</a></h1><p>There is a series of objects that define the Markov chain Monte Carlo sampler and that the user needs to define in order to be able to run the inference algorithm. To keep this processes structured an object <code>MCMCSetup</code> is defined. It allows for a systematic and concise way of defining the MCMC sampler.</p><h2><a class="nav-anchor" id="Defining-the-processes-1" href="#Defining-the-processes-1">Defining the processes</a></h2><p>To define the <code>MCMCSetup</code> one needs to decide on the <code>Target</code> diffusion an <code>Auxiliary</code> diffusion and the observation scheme. For instance, suppose that there are three observations:</p><pre><code class="language-julia">obs = [...]
obs_times = [1.0, 2.0, 3.0]</code></pre><p>Then the <code>target</code> diffusion is defined globally and the <code>auxiliary</code> diffusion is defined separately on each interval</p><pre><code class="language-julia">P_target = TargetDiffusion(parameters)
P_auxiliary = [AuxiliaryDiffusion(parameters, o, t) for (o,t) in zip(obs, obs_times)]</code></pre><p>To define the setup for partially observed diffusion it is enough to write:</p><pre><code class="language-julia">setup = MCMCSetup(P_target, P_auxiliary, PartObs()) # for first passage times use FPT()</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.MCMCSetup" href="#BridgeSDEInference.MCMCSetup"><code>BridgeSDEInference.MCMCSetup</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MCMCSetup</code></pre><p>Groups together all objects that need to be passed to <code>mcmc</code> function from <code>mcmc.jl</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L12-L17">source</a></section><h2><a class="nav-anchor" id="Observations-1" href="#Observations-1">Observations</a></h2><p>To set the observations, apart from passing the observations and observation times it is necessary to pass the observational operators and as well as covariance of the noise. Additionally, one can pass additional information about the first-passage scheme [TO DO add details on fpt].</p><pre><code class="language-julia">L = ...
Σ = ...
set_observations!(setup, [L for _ in obs], [Σ for _ in obs], obs, obs_time)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.set_observations!" href="#BridgeSDEInference.set_observations!"><code>BridgeSDEInference.set_observations!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_observations!(setup::MCMCSetup, Ls, Σs, obs, obs_times,
                  fpt=fill(nothing, length(obs)-1))</code></pre><p>Store observations to <code>setup</code>. The observations follow the scheme <code>V=LX+η</code>, where V are the observations in <code>obs</code>, observed at times given in <code>obs_times</code>, <code>L</code> are the observation operators given in <code>Ls</code>, <code>X</code> is the unobserved, underlying diffusion and <code>η</code> is a Gaussian noise with mean <code>0</code> and covariance <code>Σ</code> with the last stored in <code>Σs</code>. <code>fpt</code> provides additional information in case the nature of observations has to do with first-passage times</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L73-L83">source</a></section><h2><a class="nav-anchor" id="Imputation-grid-1" href="#Imputation-grid-1">Imputation grid</a></h2><p>There are two objects that define the imputation grid. The time step <code>dt</code> and the time transformation that transforms a regular time-grid with equidistantly distributed imputation points. The second defaults to a usual transformation employed in papers on the guided proposals. [TO DO add also space-time transformation from the original paper for the bridges]. It is enough to call</p><pre><code class="language-julia">dt = ...
set_imputation_grid!(setup, dt)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.set_imputation_grid!" href="#BridgeSDEInference.set_imputation_grid!"><code>BridgeSDEInference.set_imputation_grid!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_imputation_grid!(setup::MCMCSetup, dt,
                     time_transf=(t₀,T) -&gt; ((x) -&gt;  t₀ + (x-t₀) * (2-(x-t₀)/(T-t₀))))</code></pre><p>Define the imputation grid in <code>setup</code>. <code>dt</code> defines the granulatrity of the imputation grid and <code>time_transf</code> defines a time transformation to use for transforming equidistant grid.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L107-L114">source</a></section><h2><a class="nav-anchor" id="Transition-kernels-1" href="#Transition-kernels-1">Transition kernels</a></h2><p>To define the updates of the parameters and the Wiener path a couple of objects need to specified. A boolean flag needs to be passed indicating whether any parameter updates are to be performed. If set to <code>false</code> then only the path is updated and the result it a marginal sampler on a path space. Additionally a memory (or persistence) parameter of the preconditioned Crank-Nicolson scheme needs to be set for the path updates. For the parameter updates three additional objects must be specified. A sequence of transition kernels–-one for each Gibbs step, a sequence of lists indicating parameters to be updated–-one list for each Gibbs step and a sequence of indicators about the types of parameter updates–-one for each Gibbs step. Additionally, an object describing an adaptation scheme for the auxiliary law can be passed [TODO add description to the last]</p><h3><a class="nav-anchor" id="Random-walk-1" href="#Random-walk-1">Random walk</a></h3><p>The package provides an implementation of a <code>random walk</code>, which can be used as a generic transition kernel</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.RandomWalk" href="#BridgeSDEInference.RandomWalk"><code>BridgeSDEInference.RandomWalk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">RandomWalk(ϵ::T, pos::S)</code></pre><p>Defines a random walk on <code>|ϵ|</code>-dimensional space. `<code>ϵ</code> defines the maximal one-sided range of a single step and <code>pos</code> is a vector of indicators for whether a respective index is restricted to take only positive values. For elements restricted to take positive values, the update is done via: x⁽ⁿᵉʷ⁾ &lt;- x⁽ᵒˡᵈ⁾eᵁ, where U ∼ Unif(-ϵ,ϵ). For unrestricted: x⁽ⁿᵉʷ⁾ &lt;- x⁽ᵒˡᵈ⁾ + U, where U ∼ Unif(-ϵ,ϵ).</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/transition_kernels/random_walk.jl#L6-L15">source</a></section><h3><a class="nav-anchor" id="Indicators-for-parameter-update-1" href="#Indicators-for-parameter-update-1">Indicators for parameter update</a></h3><p>The indicators for parameter updates should be in a format of tuple of tuples (or arrays of arrays etc.). Each inner tuple corresponds to a single Gibbs step and the elements of the inner tuples give indices of parameters that are to be updated on a given Gibbs step. For instance: <code>((1,2,3),(5,))</code> says that in the first Gibbs step the first three parameters are to be updated, whereas in the second Gibbs step parameter <code>5</code> is to be updated.</p><h3><a class="nav-anchor" id="Flags-for-the-types-of-parameter-updates-1" href="#Flags-for-the-types-of-parameter-updates-1">Flags for the types of parameter updates</a></h3><p>There are currently two different ways of updating parameters:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.ConjugateUpdt" href="#BridgeSDEInference.ConjugateUpdt"><code>BridgeSDEInference.ConjugateUpdt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ConjugateUpdt &lt;: ParamUpdateType</code></pre><p>Type acting as a flag for update from full conditional (conjugate to a prior)</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/types.jl#L88-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.MetropolisHastingsUpdt" href="#BridgeSDEInference.MetropolisHastingsUpdt"><code>BridgeSDEInference.MetropolisHastingsUpdt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MetropolisHastingsUpdt &lt;: ParamUpdateType</code></pre><p>Flag for performing update according to Metropolis Hastings step</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/types.jl#L95-L99">source</a></section><h3><a class="nav-anchor" id="Setting-transition-kernels-1" href="#Setting-transition-kernels-1">Setting transition kernels</a></h3><p>An example of setting the transition kernels is as follows:</p><pre><code class="language-julia">pCN = ... # memory paramter of the preconditioned Crank Nicolson scheme
update_parameters = true
set_transition_kernels!(setup,
                        [RandomWalk([],[]),
                         RandomWalk([3.0, 5.0, 5.0, 0.01, 0.5], 5)],
                        pCN, update_parameters, ((1,2,3),(5,)),
                        (ConjugateUpdt(),
                         MetropolisHastingsUpdt(),
                        ))</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.set_transition_kernels!" href="#BridgeSDEInference.set_transition_kernels!"><code>BridgeSDEInference.set_transition_kernels!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_transition_kernels!(setup::MCMCSetup, transition_kernel,
                        crank_nicolson_memory=0.0, param_updt::Bool=true,
                        updt_coord=(Val((true,)),),
                        updt_type=(MetropolisHastingsUpdt(),),
                        adaptive_proposals=NoAdaptation())</code></pre><p>Store the transition kernels for parameter update steps as well path imputation step in the <code>setup</code> object. ...</p><p><strong>Arguments</strong></p><ul><li><code>setup</code>: object to be set up</li><li><code>transition_kernel</code>: collection of transition kernels (one for each param updt)</li><li><code>crank_nicolson_memory</code>: memory parameter for random walk on a path space</li><li><code>param_updt</code>: flag for whether to update parameters at all</li><li><code>updt_coord</code>: collection indicating which coordinates to update</li><li><code>updt_type</code>: collection indicating types of parameter updates</li><li><code>adaptive_proposals</code>: object for adapting guided proposals</li></ul><p>...</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L134-L153">source</a></section><h2><a class="nav-anchor" id="Priors-1" href="#Priors-1">Priors</a></h2><p>Priors need to be defined for each Gibbs step (or more precisely for each subset of parameters that is being updated). Additionally a prior over the starting position needs to be defined as well. A few convenience functions for the priors are provided by the package.</p><h3><a class="nav-anchor" id="Prior-over-the-starting-point-1" href="#Prior-over-the-starting-point-1">Prior over the starting point</a></h3><p>There are two types of priors for the starting point, either a <code>delta hit</code> at some specified value, corresponding to a known starting point and a Gaussian prior</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.KnownStartingPt" href="#BridgeSDEInference.KnownStartingPt"><code>BridgeSDEInference.KnownStartingPt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">KnownStartingPt{T} &lt;: StartingPtPrior</code></pre><p>Indicates that the starting point is known and stores its value in <code>y</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc_extras/starting_pt.jl#L15-L19">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.GsnStartingPt" href="#BridgeSDEInference.GsnStartingPt"><code>BridgeSDEInference.GsnStartingPt</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">GsnStartingPt{T,S} &lt;: StartingPtPrior</code></pre><p>Indicates that the starting point is equipped with a Gaussian prior with mean <code>μ</code> and covariance matrix <code>Σ</code>. It also stores the most recently sampled white noise <code>z</code> used to compute the starting point and a precision matrix <code>Λ</code>:=<code>Σ</code>⁻¹. <code>μ₀</code> and <code>Σ₀</code> are the mean and covariance of the white noise</p><pre><code class="language-none">GsnStartingPt(μ::T, Σ::S)</code></pre><p>Base constructor. It initialises the mean <code>μ</code> and covariance <code>Σ</code> parameters and <code>Λ</code> is set according to <code>Λ</code>:=<code>Σ</code>⁻¹</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc_extras/starting_pt.jl#L25-L37">source</a></section><h3><a class="nav-anchor" id="Prior-over-the-parameters-1" href="#Prior-over-the-parameters-1">Prior over the parameters</a></h3><p>An improper flat prior is provided for quick tests:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.ImproperPrior" href="#BridgeSDEInference.ImproperPrior"><code>BridgeSDEInference.ImproperPrior</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ImproperPrior</code></pre><p>Flat prior</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/types.jl#L135-L139">source</a></section><p>Additionally, as each Gibbs step needs to have its own set of priors corresponding to the parameters being updated by this Gibbs step, the priors, similarly to <code>indices of updated coordinates</code> need to be grouped into tuples of tuples. To make this grouping easier on the user a <code>Priors</code> structure is provided.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.Priors" href="#BridgeSDEInference.Priors"><code>BridgeSDEInference.Priors</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Priors</code></pre><p>Struct</p><pre><code class="language-none">struct Priors
    priors
    indicesForUpdt::Array{Array{Int64,1},1}
end</code></pre><p>holds relevant information about priors: distributions that need to be used and the pattern in which MCMC makes use of those distributions. <code>priors</code> is a list of distributions with all priors that are to be used. <code>indicesForUpdt</code> is a list of lists–-the reason is as follows. Markov chains can have multiple transition kernels, each updating (possibly) multiple number of parameters (think of Gibbs sampler, which updates parameters in blocks)–-for each such update, priors for all updated parameters are needed. The inner list of <code>indicesForUpdt</code> gives indices of all priors that together (in a factories form) make up a prior for a respective transition kernel of the Markov chain</p><pre><code class="language-none">Priors(priors, indicesForUpdt)</code></pre><p>Base constructor. <code>priors</code> is a list of priors, <code>indicesForUpdt</code> is a pattern of indices indicating in which way parameters are being updated</p><pre><code class="language-none">Priors(priors)</code></pre><p>Convenience constructor. Most of the time each kernel of the Markov chain will be updating only a single parameter and thus only a single prior will be needed for each transition. In that case providing a list of priors in <code>priors</code> is sufficient. This constructor takes care of the internal objects in such setting.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/priors.jl#L4-L33">source</a></section><h4><a class="nav-anchor" id="Example-1-1" href="#Example-1-1">Example 1</a></h4><p>This is perhaps the most common use case. Suppose that <code>n</code> coordinates–-where we take <code>n=3</code> for illustration purposes–-of prameter <code>θ</code> are being updated by the Markov chain. Suppose further that there are <code>n</code> transition kernels, each updating a separate coordinate. Let&#39;s assume for simplicity that each coordinate is equipped with an independent, improper prior. Then the <code>Priors</code> struct can be set up as follows:</p><pre><code class="language-julia">n = 3
priors = Priors([ImproperPrior() for i in 1:n])

display(priors.priors)
(ImproperPrior(), ImproperPrior(), ImproperPrior())

display(priors.indicesForUpdt)
3-element Array{Array{Int64,1},1}:
 [1]
 [2]
 [3]</code></pre><p>Notice that only a list of priors had to be supplied and the struct took care of setting up the <code>indicesForUpdt</code> container.</p><h4><a class="nav-anchor" id="Example-2-1" href="#Example-2-1">Example 2</a></h4><p>Suppose that the Markov chain uses two transition kernels. The first transition kernel updates <code>3</code> coordinates of <code>θ</code>, which have a corresponding joint, multivariate Normal prior with some pre-specified covariance matrix <code>Σ</code> and mean <code>0</code>. The second transition kernel updates <code>2</code> coordinates of <code>θ</code>, and these two are equipped with independent, improper priors. Then the <code>Priors</code> struct can be set up as follows:</p><pre><code class="language-julia">using LinearAlgebra, Distributions
Σ = diagm(0=&gt;[1000.0, 1000.0, 1000.0])
μ = [0.0,0.0,0.0]
priors = Priors([MvNormal(μ, Σ), ImproperPrior(), ImproperPrior()],
                [[1],[2,3]])
display(priors.priors)
(FullNormal(
dim: 3
μ: [0.0, 0.0, 0.0]
Σ: [1000.0 0.0 0.0; 0.0 1000.0 0.0; 0.0 0.0 1000.0]
)\mutable struct
  fields
end
, ImproperPrior(), ImproperPrior())

display(priors.indicesForUpdt)
2-element Array{Array{Int64,1},1}:
 [1]   
 [2, 3]</code></pre><p>Notice that we had to pass all priors in a list and then specify that the first transition kernel uses only the first prior, whereas the second transition kernel uses two priors from the list.</p><h3><a class="nav-anchor" id="Setting-the-priors-1" href="#Setting-the-priors-1">Setting the priors</a></h3><p>An example of setting the priors for two-step Gibbs sampler could be</p><pre><code class="language-julia">μ, Σ, λ, Ω = ..., ..., ..., ...
set_priors!(setup, Priors((MvNormal(μ, Σ), ImproperPrior())), GsnStartingPt(λ, Ω), x0)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.set_priors!" href="#BridgeSDEInference.set_priors!"><code>BridgeSDEInference.set_priors!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_priors!(setup::MCMCSetup, priors, x0_prior, x0_guess=nothing)</code></pre><p>Store the priors over parameters (in <code>priors</code>) and over the starting point (in <code>x0_prior</code>) into the object <code>setup</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L230-L235">source</a></section><h2><a class="nav-anchor" id="Blocking-1" href="#Blocking-1">Blocking</a></h2><p>Currently two choices of blocking are available:</p><ul><li>Either no blocking at all, which is the default behaviour of <code>set_blocking!</code></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.NoBlocking" href="#BridgeSDEInference.NoBlocking"><code>BridgeSDEInference.NoBlocking</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct NoBlocking &lt;: BlockingSchedule end</code></pre><p>Regular updates with no blocking</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/types.jl#L116-L120">source</a></section><ul><li>Or blocking using the chequerboard updating scheme.</li></ul><pre><code class="language-none">ChequeredBlocking</code></pre><p>For chequerboard updating scheme, at each observation a knot can be (but does not have to be) placed. IMPORTANT: The knot indexing starts at the first non-starting point observation. Suppose we have, say, <code>20</code> observations (excluding the starting point). Let&#39;s put a knot on every other observation, ending up with knots on observations with indices: <code>[2,4,6,8,10,12,14,16,18,20]</code>. Chequerboard updating scheme splits these knots into two, disjoint, interlaced subsets, i.e. <code>[2,6,10,14,18]</code> and <code>[4,8,12,16,20]</code>. This also splits the path into two interlaced sets of blocks: <code>[1–2,3–6,7–10,11–14,15–18,19–20]</code>, <code>[1–4,5–8,9–12,13–16,17–20]</code> (where interval indexing starts with interval 1, whose end-points are the starting point and the first non-starting point observation). The path is updated in blocks. First, blocks <code>[1–2,3–6,7–10,11–14,15–18,19–20]</code> are updated conditionally on full and exact observations indexed with <code>[2,6,10,14,18]</code>, as well as all the remaining, partial observations (indexed by <code>[1,2,3,...,20]</code>). Then, the other set of blocks is updated in the same manner. This is then repeated. To define the blocking behaviour, only the following needs to be written:</p><pre><code class="language-julia">blocking = ChequeredBlocking()
blocking_params = (collect(2:20)[1:2:end], 10^(-10), SimpleChangePt(100))</code></pre><p>The first defines the blocking updating scheme (in the future there might be a larger choice). The second line places the knots on <code>[2,4,6,8,10,12,14,16,18,20]</code>. Splitting into appropriate subsets is done internally. <code>10^(-10)</code> is an artificial noise parameter that needs to be added for the numerical purposes. Ideally we want this to be as small as possible, however the algorithm may have problems with dealing with very small values. The last arguments aims to remedy this. <code>SimpleChangePt(100)</code> has two functions. One, it is a flag to the <code>mcmc</code> sampler that two sets of ODE solvers need to be employed: for the segment directly adjacent to a knot from the left ODE solvers for <code>M⁺</code>, <code>L</code>, <code>μ</code> are employed and <code>H</code>, <code>Hν</code> and <code>c</code> are computed as a by-product. On the remaining part of blocks, the ODE solvers for <code>H</code>, <code>Hν</code> and <code>c</code> are used directly. The second function of <code>SimpleChangePt()</code> is to indicate the point at which a change needs to be made between these two solvers (which for the example above is set to <code>100</code>). The reason for this functionality is that solvers for <code>M⁺</code>, <code>L</code>, <code>μ</code> are more tolerant to very small values of the artificial noise.</p><p>To define an MCMC sampler with no blocking nothing needs to be done (it&#39;s a default). Alternatively, one can call</p><pre><code class="language-julia">set_blocking!()</code></pre><p>It resets the blocking to none. To pass the blocking scheme defined above one could call</p><pre><code class="language-julia">set_blocking!(setup, blocking, blocking_params)</code></pre><h2><a class="nav-anchor" id="ODE-solvers-1" href="#ODE-solvers-1">ODE solvers</a></h2><p>There are a few standard, Runge-Kutta type ODE solvers implemented for solving the backward ODE systems defining <code>M⁺</code>, <code>L</code>, <code>μ</code> and <code>H</code>, <code>Hν</code> and <code>c</code>. These are:</p><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Ralston3</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>RK4</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Tsit5</code>. Check Documenter&#39;s build log for details.</p></div></div><div class="admonition warning"><div class="admonition-title">Missing docstring.</div><div class="admonition-text"><p>Missing docstring for <code>Vern7</code>. Check Documenter&#39;s build log for details.</p></div></div><p>Additionally, the change point between solvers for <code>M⁺</code>, <code>L</code>, <code>μ</code> and <code>H</code>, <code>Hν</code> and <code>c</code> can be set outside of blocking when setting the solvers. An example code is as follows</p><pre><code class="language-julia">set_solver!(setup, Vern7(), NoChangePt())</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.set_solver!" href="#BridgeSDEInference.set_solver!"><code>BridgeSDEInference.set_solver!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_solver!(setup::MCMCSetup, solver=Ralston3(), change_pt=NoChangePt())</code></pre><p>Define the ODE solvers in <code>setup</code>. <code>solver</code> defines the type of ODE solver and <code>change_pt</code> gives information about the change point for switching between the solvers for M,L,μ and H,Hν,c</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L315-L321">source</a></section><h2><a class="nav-anchor" id="MCMC-parameters-1" href="#MCMC-parameters-1">MCMC parameters</a></h2><p>There are some additional parameters that need to be passed to an MCMC samplers. These need to be passed to</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.set_mcmc_params!" href="#BridgeSDEInference.set_mcmc_params!"><code>BridgeSDEInference.set_mcmc_params!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">set_mcmc_params!(setup::MCMCSetup, num_mcmc_steps, save_iter=NaN,
                 verb_iter=NaN, skip_for_save=1, warm_up=0)</code></pre><p>Define the parametrisation of the mcmc sampler. ...</p><p><strong>Arguments</strong></p><ul><li><code>setup</code>: object to be set up</li><li><code>num_mcmc_steps</code>: total number of steps of the mcmc sampler</li><li><code>save_iter</code>: save the path every ... iteration</li><li><code>verb_iter</code>: print progress message to console every ... iteration</li><li><code>skip_for_save</code>: when saving path, thin the grid by a factor of ...</li><li><code>uwarm_up</code>: number of steps of the chain in which no param update is made</li></ul><p>...</p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L258-L272">source</a></section><h2><a class="nav-anchor" id="Initialisation-of-internal-containers-1" href="#Initialisation-of-internal-containers-1">Initialisation of internal containers</a></h2><p>Once all the setting functions above have been run (with the only exception <code>set_blocking!</code> being optional), i.e.</p><pre><code class="language-julia">setup = MCMCSetup(...)
set_observations!(setup, ...)
set_imputation_grid(setup, ...)
set_transition_kernels!(setup, ...)
set_priors!(setup, ...)
set_mcmc_params!(setup, ...)
set_solver!(setup, ...)
set_blocking(setup, ...) # optionally</code></pre><p>then the following function should be run</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BridgeSDEInference.initialise!" href="#BridgeSDEInference.initialise!"><code>BridgeSDEInference.initialise!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">initialise(::Type{K}, setup::MCMCSetup; verbose=false)</code></pre><p>Initialise the internal containers of <code>setup</code>. Check if all the necessary data has been passed to <code>setup</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/mmider/BridgeSDEInference.jl/blob/61330a54d1cda4719c46a8a2d91499eeb7ae6c72/src/mcmc/setup.jl#L511-L515">source</a></section><p>Once run, the setup is complete and it is possible to commence the MCMC sampler. </p><footer><hr/><a class="previous" href="../generate_data/"><span class="direction">Previous</span><span class="title">Data generation</span></a><a class="next" href="../run/"><span class="direction">Next</span><span class="title">Running the sampler</span></a></footer></article></body></html>
