var documenterSearchIndex = {"docs":
[{"location":"examples/sine/#Sine-diffusion-1","page":"Sine diffusion","title":"Sine diffusion","text":"","category":"section"},{"location":"examples/sine/#","page":"Sine diffusion","title":"Sine diffusion","text":"d X_t = a + bsin(c + X_t)dt + sigma dW_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"man/setup/#Defining-the-observational-scheme-and-parameters-of-the-Markov-chain-1","page":"Setup","title":"Defining the observational scheme and parameters of the Markov chain","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"There is a series of objects that define the Markov chain Monte Carlo sampler and that the user needs to define in order to be able to run the inference algorithm. To keep this processes structured an object MCMCSetup is defined. It allows for a systematic and concise way of defining the MCMC sampler.","category":"page"},{"location":"man/setup/#Defining-the-processes-1","page":"Setup","title":"Defining the processes","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"To define the MCMCSetup one needs to decide on the Target diffusion an Auxiliary diffusion and the observation scheme. For instance, suppose that there are three observations:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"obs = [...]\nobs_times = [1.0, 2.0, 3.0]","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Then the target diffusion is defined globally and the auxiliary diffusion is defined separately on each interval","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"P_target = TargetDiffusion(parameters)\nP_auxiliary = [AuxiliaryDiffusion(parameters, o, t) for (o,t) in zip(obs, obs_times)]","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"To define the setup for partially observed diffusion it is enough to write:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"setup = MCMCSetup(P_target, P_auxiliary, PartObs()) # for first passage times use FPT()","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"MCMCSetup","category":"page"},{"location":"man/setup/#BridgeSDEInference.MCMCSetup","page":"Setup","title":"BridgeSDEInference.MCMCSetup","text":"MCMCSetup\n\nGroups together all objects that need to be passed to mcmc function from mcmc.jl.\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#Observations-1","page":"Setup","title":"Observations","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"To set the observations, apart from passing the observations and observation times it is necessary to pass the observational operators and as well as covariance of the noise. Additionally, one can pass additional information about the first-passage scheme [TO DO add details on fpt].","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"L = ...\nΣ = ...\nset_observations!(setup, [L for _ in obs], [Σ for _ in obs], obs, obs_time)","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_observations!","category":"page"},{"location":"man/setup/#BridgeSDEInference.set_observations!","page":"Setup","title":"BridgeSDEInference.set_observations!","text":"set_observations!(setup::MCMCSetup, Ls, Σs, obs, obs_times,\n                  fpt=fill(nothing, length(obs)-1))\n\nStore observations to setup. The observations follow the scheme V=LX+η, where V are the observations in obs, observed at times given in obs_times, L are the observation operators given in Ls, X is the unobserved, underlying diffusion and η is a Gaussian noise with mean 0 and covariance Σ with the last stored in Σs. fpt provides additional information in case the nature of observations has to do with first-passage times\n\n\n\n\n\n","category":"function"},{"location":"man/setup/#Imputation-grid-1","page":"Setup","title":"Imputation grid","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"There are two objects that define the imputation grid. The time step dt and the time transformation that transforms a regular time-grid with equidistantly distributed imputation points. The second defaults to a usual transformation employed in papers on the guided proposals. [TO DO add also space-time transformation from the original paper for the bridges]. It is enough to call","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"dt = ...\nset_imputation_grid!(setup, dt)","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_imputation_grid!","category":"page"},{"location":"man/setup/#BridgeSDEInference.set_imputation_grid!","page":"Setup","title":"BridgeSDEInference.set_imputation_grid!","text":"set_imputation_grid!(setup::MCMCSetup, dt,\n                     time_transf=(t₀,T) -> ((x) ->  t₀ + (x-t₀) * (2-(x-t₀)/(T-t₀))))\n\nDefine the imputation grid in setup. dt defines the granulatrity of the imputation grid and time_transf defines a time transformation to use for transforming equidistant grid.\n\n\n\n\n\n","category":"function"},{"location":"man/setup/#Transition-kernels-1","page":"Setup","title":"Transition kernels","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"To define the updates of the parameters and the Wiener path a couple of objects need to specified. A boolean flag needs to be passed indicating whether any parameter updates are to be performed. If set to false then only the path is updated and the result it a marginal sampler on a path space. Additionally a memory (or persistence) parameter of the preconditioned Crank-Nicolson scheme needs to be set for the path updates. For the parameter updates three additional objects must be specified. A sequence of transition kernels–-one for each Gibbs step, a sequence of lists indicating parameters to be updated–-one list for each Gibbs step and a sequence of indicators about the types of parameter updates–-one for each Gibbs step. Additionally, an object describing an adaptation scheme for the auxiliary law can be passed [TODO add description to the last]","category":"page"},{"location":"man/setup/#Random-walk-1","page":"Setup","title":"Random walk","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"The package provides an implementation of a random walk, which can be used as a generic transition kernel","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"RandomWalk","category":"page"},{"location":"man/setup/#BridgeSDEInference.RandomWalk","page":"Setup","title":"BridgeSDEInference.RandomWalk","text":"RandomWalk(ϵ::T, pos::S)\n\nDefines a random walk on |ϵ|-dimensional space. `ϵ defines the maximal one-sided range of a single step and pos is a vector of indicators for whether a respective index is restricted to take only positive values. For elements restricted to take positive values, the update is done via: x⁽ⁿᵉʷ⁾ <- x⁽ᵒˡᵈ⁾eᵁ, where U ∼ Unif(-ϵ,ϵ). For unrestricted: x⁽ⁿᵉʷ⁾ <- x⁽ᵒˡᵈ⁾ + U, where U ∼ Unif(-ϵ,ϵ).\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#Indicators-for-parameter-update-1","page":"Setup","title":"Indicators for parameter update","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"The indicators for parameter updates should be in a format of tuple of tuples (or arrays of arrays etc.). Each inner tuple corresponds to a single Gibbs step and the elements of the inner tuples give indices of parameters that are to be updated on a given Gibbs step. For instance: ((1,2,3),(5,)) says that in the first Gibbs step the first three parameters are to be updated, whereas in the second Gibbs step parameter 5 is to be updated.","category":"page"},{"location":"man/setup/#Flags-for-the-types-of-parameter-updates-1","page":"Setup","title":"Flags for the types of parameter updates","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"There are currently two different ways of updating parameters:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"ConjugateUpdt\nMetropolisHastingsUpdt","category":"page"},{"location":"man/setup/#BridgeSDEInference.ConjugateUpdt","page":"Setup","title":"BridgeSDEInference.ConjugateUpdt","text":"ConjugateUpdt <: ParamUpdateType\n\nType acting as a flag for update from full conditional (conjugate to a prior)\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#BridgeSDEInference.MetropolisHastingsUpdt","page":"Setup","title":"BridgeSDEInference.MetropolisHastingsUpdt","text":"MetropolisHastingsUpdt <: ParamUpdateType\n\nFlag for performing update according to Metropolis Hastings step\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#Setting-transition-kernels-1","page":"Setup","title":"Setting transition kernels","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"An example of setting the transition kernels is as follows:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"pCN = ... # memory paramter of the preconditioned Crank Nicolson scheme\nupdate_parameters = true\nset_transition_kernels!(setup,\n                        [RandomWalk([],[]),\n                         RandomWalk([3.0, 5.0, 5.0, 0.01, 0.5], 5)],\n                        pCN, update_parameters, ((1,2,3),(5,)),\n                        (ConjugateUpdt(),\n                         MetropolisHastingsUpdt(),\n                        ))","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_transition_kernels!","category":"page"},{"location":"man/setup/#BridgeSDEInference.set_transition_kernels!","page":"Setup","title":"BridgeSDEInference.set_transition_kernels!","text":"set_transition_kernels!(setup::MCMCSetup, transition_kernel,\n                        crank_nicolson_memory=0.0, param_updt::Bool=true,\n                        updt_coord=(Val((true,)),),\n                        updt_type=(MetropolisHastingsUpdt(),),\n                        adaptive_proposals=NoAdaptation())\n\nStore the transition kernels for parameter update steps as well path imputation step in the setup object. ...\n\nArguments\n\nsetup: object to be set up\ntransition_kernel: collection of transition kernels (one for each param updt)\ncrank_nicolson_memory: memory parameter for random walk on a path space\nparam_updt: flag for whether to update parameters at all\nupdt_coord: collection indicating which coordinates to update\nupdt_type: collection indicating types of parameter updates\nadaptive_proposals: object for adapting guided proposals\n\n...\n\n\n\n\n\n","category":"function"},{"location":"man/setup/#Priors-1","page":"Setup","title":"Priors","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Priors need to be defined for each Gibbs step (or more precisely for each subset of parameters that is being updated). Additionally a prior over the starting position needs to be defined as well. A few convenience functions for the priors are provided by the package.","category":"page"},{"location":"man/setup/#Prior-over-the-starting-point-1","page":"Setup","title":"Prior over the starting point","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"There are two types of priors for the starting point, either a delta hit at some specified value, corresponding to a known starting point and a Gaussian prior","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"KnownStartingPt\nGsnStartingPt","category":"page"},{"location":"man/setup/#BridgeSDEInference.KnownStartingPt","page":"Setup","title":"BridgeSDEInference.KnownStartingPt","text":"KnownStartingPt{T} <: StartingPtPrior\n\nIndicates that the starting point is known and stores its value in y\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#BridgeSDEInference.GsnStartingPt","page":"Setup","title":"BridgeSDEInference.GsnStartingPt","text":"GsnStartingPt{T,S} <: StartingPtPrior\n\nIndicates that the starting point is equipped with a Gaussian prior with mean μ and covariance matrix Σ. It also stores the most recently sampled white noise z used to compute the starting point and a precision matrix Λ:=Σ⁻¹. μ₀ and Σ₀ are the mean and covariance of the white noise\n\nGsnStartingPt(μ::T, Σ::S)\n\nBase constructor. It initialises the mean μ and covariance Σ parameters and Λ is set according to Λ:=Σ⁻¹\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#Prior-over-the-parameters-1","page":"Setup","title":"Prior over the parameters","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"An improper flat prior is provided for quick tests:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"ImproperPrior","category":"page"},{"location":"man/setup/#BridgeSDEInference.ImproperPrior","page":"Setup","title":"BridgeSDEInference.ImproperPrior","text":"ImproperPrior\n\nFlat prior\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Additionally, as each Gibbs step needs to have its own set of priors corresponding to the parameters being updated by this Gibbs step, the priors, similarly to indices of updated coordinates need to be grouped into tuples of tuples. To make this grouping easier on the user a Priors structure is provided.","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Priors","category":"page"},{"location":"man/setup/#BridgeSDEInference.Priors","page":"Setup","title":"BridgeSDEInference.Priors","text":"Priors\n\nStruct\n\nstruct Priors\n    priors\n    indicesForUpdt::Array{Array{Int64,1},1}\nend\n\nholds relevant information about priors: distributions that need to be used and the pattern in which MCMC makes use of those distributions. priors is a list of distributions with all priors that are to be used. indicesForUpdt is a list of lists–-the reason is as follows. Markov chains can have multiple transition kernels, each updating (possibly) multiple number of parameters (think of Gibbs sampler, which updates parameters in blocks)–-for each such update, priors for all updated parameters are needed. The inner list of indicesForUpdt gives indices of all priors that together (in a factories form) make up a prior for a respective transition kernel of the Markov chain\n\nPriors(priors, indicesForUpdt)\n\nBase constructor. priors is a list of priors, indicesForUpdt is a pattern of indices indicating in which way parameters are being updated\n\nPriors(priors)\n\nConvenience constructor. Most of the time each kernel of the Markov chain will be updating only a single parameter and thus only a single prior will be needed for each transition. In that case providing a list of priors in priors is sufficient. This constructor takes care of the internal objects in such setting.\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#Example-1-1","page":"Setup","title":"Example 1","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"This is perhaps the most common use case. Suppose that n coordinates–-where we take n=3 for illustration purposes–-of prameter θ are being updated by the Markov chain. Suppose further that there are n transition kernels, each updating a separate coordinate. Let's assume for simplicity that each coordinate is equipped with an independent, improper prior. Then the Priors struct can be set up as follows:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"n = 3\npriors = Priors([ImproperPrior() for i in 1:n])\n\ndisplay(priors.priors)\n(ImproperPrior(), ImproperPrior(), ImproperPrior())\n\ndisplay(priors.indicesForUpdt)\n3-element Array{Array{Int64,1},1}:\n [1]\n [2]\n [3]","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Notice that only a list of priors had to be supplied and the struct took care of setting up the indicesForUpdt container.","category":"page"},{"location":"man/setup/#Example-2-1","page":"Setup","title":"Example 2","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Suppose that the Markov chain uses two transition kernels. The first transition kernel updates 3 coordinates of θ, which have a corresponding joint, multivariate Normal prior with some pre-specified covariance matrix Σ and mean 0. The second transition kernel updates 2 coordinates of θ, and these two are equipped with independent, improper priors. Then the Priors struct can be set up as follows:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"using LinearAlgebra, Distributions\nΣ = diagm(0=>[1000.0, 1000.0, 1000.0])\nμ = [0.0,0.0,0.0]\npriors = Priors([MvNormal(μ, Σ), ImproperPrior(), ImproperPrior()],\n                [[1],[2,3]])\ndisplay(priors.priors)\n(FullNormal(\ndim: 3\nμ: [0.0, 0.0, 0.0]\nΣ: [1000.0 0.0 0.0; 0.0 1000.0 0.0; 0.0 0.0 1000.0]\n)\\mutable struct\n  fields\nend\n, ImproperPrior(), ImproperPrior())\n\ndisplay(priors.indicesForUpdt)\n2-element Array{Array{Int64,1},1}:\n [1]   \n [2, 3]","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Notice that we had to pass all priors in a list and then specify that the first transition kernel uses only the first prior, whereas the second transition kernel uses two priors from the list.","category":"page"},{"location":"man/setup/#Setting-the-priors-1","page":"Setup","title":"Setting the priors","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"An example of setting the priors for two-step Gibbs sampler could be","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"μ, Σ, λ, Ω = ..., ..., ..., ...\nset_priors!(setup, Priors((MvNormal(μ, Σ), ImproperPrior())), GsnStartingPt(λ, Ω), x0)","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_priors!","category":"page"},{"location":"man/setup/#BridgeSDEInference.set_priors!","page":"Setup","title":"BridgeSDEInference.set_priors!","text":"set_priors!(setup::MCMCSetup, priors, x0_prior, x0_guess=nothing)\n\nStore the priors over parameters (in priors) and over the starting point (in x0_prior) into the object setup.\n\n\n\n\n\n","category":"function"},{"location":"man/setup/#Blocking-1","page":"Setup","title":"Blocking","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Currently two choices of blocking are available:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Either no blocking at all, which is the default behaviour of set_blocking!","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"NoBlocking","category":"page"},{"location":"man/setup/#BridgeSDEInference.NoBlocking","page":"Setup","title":"BridgeSDEInference.NoBlocking","text":"struct NoBlocking <: BlockingSchedule end\n\nRegular updates with no blocking\n\n\n\n\n\n","category":"type"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Or blocking using the chequerboard updating scheme.","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"ChequeredBlocking","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"For chequerboard updating scheme, at each observation a knot can be (but does not have to be) placed. IMPORTANT: The knot indexing starts at the first non-starting point observation. Suppose we have, say, 20 observations (excluding the starting point). Let's put a knot on every other observation, ending up with knots on observations with indices: [2,4,6,8,10,12,14,16,18,20]. Chequerboard updating scheme splits these knots into two, disjoint, interlaced subsets, i.e. [2,6,10,14,18] and [4,8,12,16,20]. This also splits the path into two interlaced sets of blocks: [1–2,3–6,7–10,11–14,15–18,19–20], [1–4,5–8,9–12,13–16,17–20] (where interval indexing starts with interval 1, whose end-points are the starting point and the first non-starting point observation). The path is updated in blocks. First, blocks [1–2,3–6,7–10,11–14,15–18,19–20] are updated conditionally on full and exact observations indexed with [2,6,10,14,18], as well as all the remaining, partial observations (indexed by [1,2,3,...,20]). Then, the other set of blocks is updated in the same manner. This is then repeated. To define the blocking behaviour, only the following needs to be written:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"blocking = ChequeredBlocking()\nblocking_params = (collect(2:20)[1:2:end], 10^(-10), SimpleChangePt(100))","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"The first defines the blocking updating scheme (in the future there might be a larger choice). The second line places the knots on [2,4,6,8,10,12,14,16,18,20]. Splitting into appropriate subsets is done internally. 10^(-10) is an artificial noise parameter that needs to be added for the numerical purposes. Ideally we want this to be as small as possible, however the algorithm may have problems with dealing with very small values. The last arguments aims to remedy this. SimpleChangePt(100) has two functions. One, it is a flag to the mcmc sampler that two sets of ODE solvers need to be employed: for the segment directly adjacent to a knot from the left ODE solvers for M⁺, L, μ are employed and H, Hν and c are computed as a by-product. On the remaining part of blocks, the ODE solvers for H, Hν and c are used directly. The second function of SimpleChangePt() is to indicate the point at which a change needs to be made between these two solvers (which for the example above is set to 100). The reason for this functionality is that solvers for M⁺, L, μ are more tolerant to very small values of the artificial noise.","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"To define an MCMC sampler with no blocking nothing needs to be done (it's a default). Alternatively, one can call","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_blocking!()","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"It resets the blocking to none. To pass the blocking scheme defined above one could call","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_blocking!(setup, blocking, blocking_params)","category":"page"},{"location":"man/setup/#ODE-solvers-1","page":"Setup","title":"ODE solvers","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"There are a few standard, Runge-Kutta type ODE solvers implemented for solving the backward ODE systems defining M⁺, L, μ and H, Hν and c. These are:","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Ralston3\nRK4\nTsit5\nVern7","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Additionally, the change point between solvers for M⁺, L, μ and H, Hν and c can be set outside of blocking when setting the solvers. An example code is as follows","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_solver!(setup, Vern7(), NoChangePt())","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_solver!","category":"page"},{"location":"man/setup/#BridgeSDEInference.set_solver!","page":"Setup","title":"BridgeSDEInference.set_solver!","text":"set_solver!(setup::MCMCSetup, solver=Ralston3(), change_pt=NoChangePt())\n\nDefine the ODE solvers in setup. solver defines the type of ODE solver and change_pt gives information about the change point for switching between the solvers for M,L,μ and H,Hν,c\n\n\n\n\n\n","category":"function"},{"location":"man/setup/#MCMC-parameters-1","page":"Setup","title":"MCMC parameters","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"There are some additional parameters that need to be passed to an MCMC samplers. These need to be passed to","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"set_mcmc_params!","category":"page"},{"location":"man/setup/#BridgeSDEInference.set_mcmc_params!","page":"Setup","title":"BridgeSDEInference.set_mcmc_params!","text":"set_mcmc_params!(setup::MCMCSetup, num_mcmc_steps, save_iter=NaN,\n                 verb_iter=NaN, skip_for_save=1, warm_up=0)\n\nDefine the parametrisation of the mcmc sampler. ...\n\nArguments\n\nsetup: object to be set up\nnum_mcmc_steps: total number of steps of the mcmc sampler\nsave_iter: save the path every ... iteration\nverb_iter: print progress message to console every ... iteration\nskip_for_save: when saving path, thin the grid by a factor of ...\nuwarm_up: number of steps of the chain in which no param update is made\n\n...\n\n\n\n\n\n","category":"function"},{"location":"man/setup/#Initialisation-of-internal-containers-1","page":"Setup","title":"Initialisation of internal containers","text":"","category":"section"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Once all the setting functions above have been run (with the only exception set_blocking! being optional), i.e.","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"setup = MCMCSetup(...)\nset_observations!(setup, ...)\nset_imputation_grid(setup, ...)\nset_transition_kernels!(setup, ...)\nset_priors!(setup, ...)\nset_mcmc_params!(setup, ...)\nset_solver!(setup, ...)\nset_blocking(setup, ...) # optionally","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"then the following function should be run","category":"page"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"initialise!","category":"page"},{"location":"man/setup/#BridgeSDEInference.initialise!","page":"Setup","title":"BridgeSDEInference.initialise!","text":"initialise(::Type{K}, setup::MCMCSetup; verbose=false)\n\nInitialise the internal containers of setup. Check if all the necessary data has been passed to setup\n\n\n\n\n\n","category":"function"},{"location":"man/setup/#","page":"Setup","title":"Setup","text":"Once run, the setup is complete and it is possible to commence the MCMC sampler. ","category":"page"},{"location":"man/run/#Running-the-MCMC-sampler-1","page":"Running the sampler","title":"Running the MCMC sampler","text":"","category":"section"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"Running the MCMC sampler is very simple, it is enough to call","category":"page"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"mcmc","category":"page"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"passing the initialised MCMCsetup object, as follows:","category":"page"},{"location":"man/run/#","page":"Running the sampler","title":"Running the sampler","text":"out = mcmc(setup)","category":"page"},{"location":"man/query/#Querying-the-inference-results-1","page":"Querying the results","title":"Querying the inference results","text":"","category":"section"},{"location":"man/query/#","page":"Querying the results","title":"Querying the results","text":"The output of running the mcmc function is a Workspace object.","category":"page"},{"location":"man/query/#","page":"Querying the results","title":"Querying the results","text":"Workspace","category":"page"},{"location":"man/query/#BridgeSDEInference.Workspace","page":"Querying the results","title":"BridgeSDEInference.Workspace","text":"Workspace{ObsScheme,S,TX,TW,R,ST}\n\nThe main container of the mcmc function from mcmc.jl in which most data pertinent to sampling is stored\n\n\n\n\n\n","category":"type"},{"location":"man/query/#","page":"Querying the results","title":"Querying the results","text":"Querying the output can be done simply by calling the members of an instance of Workspace that is returned by the mcmc sampler. The task of writing suitable functions for this is left mainly to the user, we provide some generic plotting functions that can be used for testing here (not part of the package).","category":"page"},{"location":"examples/fitzhugh_nagumo/#Parametrisations-of-FitzHugh-Nagumo-model-1","page":"FitzHugh-Nagumo model","title":"Parametrisations of FitzHugh-Nagumo model","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"There are 5 distinct parametrisations of the FitzHugh-Nagumo model implemented in this package. They are explained in turn below","category":"page"},{"location":"examples/fitzhugh_nagumo/#:regular-1","page":"FitzHugh-Nagumo model","title":":regular","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"This is the most commonly encountered parametrisation of the FitzHugh-Nagumo model. The target, two dimensional process (Y,X) solves the following stochastic differential equation:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd Y_t = frac1epsilonleft( Y_t - Y_t^3-X_t + s right )dt\ndX_t = left( gamma Y_t - X_t + beta right )dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The proposal is taken to be a guided proposal with auxiliary law (Image: equation) induced by the linear diffusion obtained by linearising FitzHugh-Nagumo diffusion at an end-point:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd widetildeY_t = frac1epsilonleft( left( 1-3y_T^2 right )widetildeY_t - widetildeX_t + s + 2y_T^3 right)dt\ndwidetildeX_t = left( gamma widetildeY_t - widetildeX_t + beta right)dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:simpleAlter-1","page":"FitzHugh-Nagumo model","title":":simpleAlter","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The target stochastic differential equations is re-parametrised in such a way that the first coordinate is given by the integrated second coordinate:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd Y_t = dotY_t dt\nddotY_t = frac1epsilonleft( (1-gamma)Y_t -Y_t^3 -epsilon dotY_t + s - beta + left( 1-3Y_t^2 right)dotY_t right)dt + fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The auxiliary law (Image: equation) is now induced by a pair: (I,B), where B is a scaled Brownian motion and I is an integrated B:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd I_t = B_tdt\ndB_t = fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:complexAlter-1","page":"FitzHugh-Nagumo model","title":":complexAlter","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"The stochastic differential equation solved by the target process is the same as in :simpleAlter. However, the auxliary law (Image: equation) is induced by a two-dimensional diffusion, where the second coordinate is a linear diffusion obtained from linearising (Image: equation) at an end-point and the first coordinate is an integrated second coordinate. If only the first coordinate is observed the proposal takes a form:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndwidetildeY_t = widetildeX_t dt\ndwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 right )widetildeY_t +left( 1-epsilon-3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta right )right dt + fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"On the other hand, if both coordinates are observed, the proposal is given by:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndwidetildeY_t = widetildeX_t dt\ndwidetildeX_t = frac1epsilonleft left( 1-gamma-3y_T^2 - 6y_Tdoty_T right )widetildeY_t +left( 1-epsilon -3y_T^2 right )widetildeX_t + left(2y_T^3+s-beta + 6y_T^2doty_T right )right dt + fracsigmaepsilondW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:simpleConjug-1","page":"FitzHugh-Nagumo model","title":":simpleConjug","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to :simpleAlter, the only difference being that an additional step is taken of redefining the parameters:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"sleftarrow fracsepsilonquad betaleftarrowfracbetaepsilonquad sigmaleftarrowfracsigmaepsilonquad gammaleftarrowfracgammaepsilonquad epsilonleftarrowfrac1epsilon","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"This results in the target law of the form:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd Y_t = dotY_t dt\nddotY_t = left( (epsilon-gamma)Y_t -epsilon Y_t^3 -dotY_t + s - beta + epsilonleft( 1-3Y_t^2 right)dotY_t right)dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"And the proposal law:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\nd I_t = B_tdt\ndB_t = sigma dW_t\nendalign*","category":"page"},{"location":"examples/fitzhugh_nagumo/#:complexConjug-1","page":"FitzHugh-Nagumo model","title":":complexConjug","text":"","category":"section"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"It is defined analogously to :complexAlter, the only difference being that an additional step is taken of redefining the parameters (just as it was done in :simpleConjug above). Consequently the target law is as given above, in the section on :simpleConjug parametrisation, whereas proposal law is given by:","category":"page"},{"location":"examples/fitzhugh_nagumo/#","page":"FitzHugh-Nagumo model","title":"FitzHugh-Nagumo model","text":"beginalign*\ndwidetildeY_t = widetildeX_t dt\ndwidetildeX_t = left left epsilonleft(1-3y_T^2 - 6y_Tdoty_T right )-gamma right widetildeY_t +left epsilonleft( 1-3y_T^2 right)-1 right widetildeX_t + leftepsilonleft(2y_T^3+ 6y_T^2doty_T right ) +s-beta rightright dt + sigma dW_t\nendalign*","category":"page"},{"location":"examples/prokaryote/#Prokaryotic-autoregulatory-gene-network-1","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"","category":"section"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"dX_t = b(X_t)dt + sigma(X_t) dW_t","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"where","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"b(x)=left(beginmatrix\nc_3 x^4 - c_7 x^1\nc_4 x^1 + 2f(x) - c_8 x^3\ng(x)-f(x)\ng(x)\nendmatrixright)","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"with","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"beginalign*\nf(x)=c_6 x^3-05c_5x^2(x^2-1)\ng(x)=c_2(K-x^4)-c_1 x^3x^4\nendalign*","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"and","category":"page"},{"location":"examples/prokaryote/#","page":"Prokaryotic autoregulatory gene network","title":"Prokaryotic autoregulatory gene network","text":"sigma(x)","category":"page"},{"location":"man/model_definition/#Definition-of-a-diffusion-process-1","page":"Defining a diffusion","title":"Definition of a diffusion process","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"To define a diffusion model suitable for inference with BridgeSDEInference.jl one must define two processes:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"the target diffusion\nand the auxiliary diffusion","category":"page"},{"location":"man/model_definition/#Imports-1","page":"Defining a diffusion","title":"Imports","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"The diffusion definitions will extend some of the functionality of the existing functions from Bridge.jl, so the following imports are necessary:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"using Bridge\nimport Bridge: b, σ, B, β, a, constdiff","category":"page"},{"location":"man/model_definition/#Definition-of-the-target-process-1","page":"Defining a diffusion","title":"Definition of the target process","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"The target process needs to be a struct inheriting from ContinuousTimeProcess{ℝ{d,T}} (where d is a dimension of the diffusion) with the first type parameter {T} defining the data-type of the parameters. The members of the struct must define the diffusion process and are usually limited to a list of parameters. An example of a valid definition of a 10 dimensional diffusion with two parameters alpha and beta would be","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"struct TargetDiffusion{T} <: ContinuousTimeProcess{ℝ{10,T}}\n    α::T\n    β::T\n    TargetDiffusion(α::T, β::T) where T = new{T}(α, β)\nend","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"Then, one must specify the dynamics of the diffusion by specifying the behaviour of the drift and volatility functions b and σ (defined in Bridge.jl) for TargetDiffusion:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"b(t, x, P::TargetDiffusion) = foo(t, x, P.α, P.β)\nσ(t, x, P::TargetDiffusion) = bar(t, x, P.α, P.β)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"where foo and bar are some user-defined functions. Finally, three auxiliary functions must be defined:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"constdiff(::TargetDiffusion) = false","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"indicating whether σ(t, x, P::TargetDiffusion) is independent from the values of x and t,","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"clone(P::TargetDiffusion, θ) = TargetDiffusion(θ...)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"which returns a new copy of the process with new set of parameters, and finally","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"params(P::TargetDiffusion) = [P.α, P.β]","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"which returns an array with all parameter values. Optionally, functions nonhypo, hypo_a_inv, num_non_hypo and phi can be defined to make it possible to perform conjugate updates of the parameters (see ... for more details on conjugate updates [TODO add])","category":"page"},{"location":"man/model_definition/#Definition-of-the-auxiliary-process-1","page":"Defining a diffusion","title":"Definition of the auxiliary process","text":"","category":"section"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"The auxiliary diffusion, similarly, needs to be a struct inheriting from ContinuousTimeProcess{ℝ{d,T}} with the first type parameter {T} defining the data-type of the parameters. It is often necessary for the auxiliary diffusion to have to have access to the information regarding the starting and ending time of the interval on which it is defined. Additionally, the starting and end-point of the target process are also sometimes used (if available). An example of a definition of the auxiliary diffusion is:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"struct AuxiliaryDiffusion{R,S1,S2}\n    α::R\n    β::R\n    t::Float64    # starting time of the interval\n    u::S1         # starting position of the target process\n    T::Float64    # end-time of the interval\n    v::S2         # final position of the target process\n    AuxiliaryDiffusion(α::R, β::R, t, u::S1, T, v::S2) = new{R,S1,S2}(α, β, t, u, T, v)\nend","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"It is now necessary to specify the dynamics of the process. Unlike in the case of the Target, specifying the volatility coefficient is not necessary and it is sufficient to only provide a diffusion coefficient (a:=σσ'). The package supports only linear diffusions as auxiliary processes and thus function b should be defined as:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"b(t, x, P::AuxiliaryDiffusion) = B(t, P) * x + β(t, P)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"where B and β need to be overwritten as follows:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"B(t, P::AuxiliaryDiffusion) = foo2(t, P)\nβ(t, P::AuxiliaryDiffusion) = foo3(t, P)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"where the user-defined functions foo2 and foo3 should return a d by d matrix and a length-d vector respectively. One needs to define the diffusion coefficient","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"a(t, P::AuxiliaryDiffusion) = bar2(t, P)","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"As previously, the clone constructor, params and also a convenience function returning the names of the paramters:","category":"page"},{"location":"man/model_definition/#","page":"Defining a diffusion","title":"Defining a diffusion","text":"clone(P::AuxiliaryDiffusion, θ) = AuxiliaryDiffusion(θ..., P.t, P.u, P.T, P.v)\nparams(P::AuxiliaryDiffusion) = (P.α, P.β)\nparam_names(P::AuxiliaryDiffusion) = (:α, :β)","category":"page"},{"location":"examples/lorenz63/#Lorenz-'63-system-1","page":"Lorenz63 system","title":"Lorenz '63 system","text":"","category":"section"},{"location":"examples/lorenz63/#","page":"Lorenz63 system","title":"Lorenz63 system","text":"beginalign*\nd X_t = a (Y_t - X_t) dt + sigma_x dW^(1)_t \ndY_t = X_t (b - Z_t) - Y_tdt + sigma_y dW^(2)_t\ndZ_t = X_t Y_t - c Z_tdt + dW^(3)_t\nendalign*","category":"page"},{"location":"man/overview/#Overview-of-the-workflow-1","page":"Workflow","title":"Overview of the workflow","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"A typical workflow consists of four stages (or five if the data also needs to be generated).","category":"page"},{"location":"man/overview/#Stage-1-(a)-1","page":"Workflow","title":"Stage 1 (a)","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Define a diffusion model. Some examples are included in the folder src/examples. See Definition of a diffusion process for a list of functions that need (and optionally might) be implemented to fully define a diffusion process.","category":"page"},{"location":"man/overview/#Stage-1-(b)-1","page":"Workflow","title":"Stage 1 (b)","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Generate the data. Naturally in applied work the data is given and this step is skipped. However, for tests it is often convenient to work with simulated data. Data generation is not an internal part of the package; however some generic methods that allow for simulation of observations can be found in folders (...). See also Data Generation.","category":"page"},{"location":"man/overview/#Stage-2-1","page":"Workflow","title":"Stage 2","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Define the observational setup, together with the parametrisation of the Markov chain Monte Carlo sampler. There are a lot of elements that can be tailored by the user at this step; however, much of the heavy work of code writing is taken care of by the internal routines of the package and the amount of code that needs to be written by the user is conveniently kept to a minimum. This comes at a cost of having to familiarise oneself with the syntax used to define the observational scheme and the MCMC; please see Setup to view available options regarding the setup.","category":"page"},{"location":"man/overview/#Stage-3-1","page":"Workflow","title":"Stage 3","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Run the mcmc function. This is a one-liner:","category":"page"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"out = mcmc(setup)","category":"page"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"where setup is an appropriately defined observational setup and definition of the Markov chain.","category":"page"},{"location":"man/overview/#Stage-4-1","page":"Workflow","title":"Stage 4","text":"","category":"section"},{"location":"man/overview/#","page":"Workflow","title":"Workflow","text":"Query the results. This step is mostly left to a user. There are a couple of generic plotting functions defined in (...), which are not part of the package. The output is an object Workspace, please see Query for an overview of its members and some auxiliary functions that can be used to visualise the results.","category":"page"},{"location":"vis/visualisation/#Visualisations-1","page":"Visualisation tools","title":"Visualisations","text":"","category":"section"},{"location":"vis/visualisation/#","page":"Visualisation tools","title":"Visualisation tools","text":"Interactive visualisations of the FitzHugh-Nagumo system using Makie library are given here","category":"page"},{"location":"examples/jansen_rit/#Jansen-Rit-model-1","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"","category":"section"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"beginequation*\n    beginaligned\n        d X_t = dot X_t d t  \n        d Y_t = dot Y_t d t  \n        d Z_t = dot Z_t d t \n        d dot X_t =   leftA a left(mu_x(t) + mboxSigm(Y_t - Z_t)right) - 2a dot X_t - a^2 X_tright d t + sigma_x d W^(1)_t\n        d dot Y_t =  leftA a left(mu_y(t) + C_2mboxSigm(C_1 X_t)right) - 2a dot Y_t - a^2 Y_tright d t + sigma_y d W^(2)_t\n        d dot Z_t =  leftB b left(mu_z(t) + C_4mboxSigm(C_3 X_t)right) - 2b dot Z_t - b^2 Z_tright d t + sigma_z d W^(3)_t\n    endaligned\nendequation*","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"with initial condition","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"(X_0Y_0Z_0 dot X_0 dot Y_0 dot Z_0)=(x_0y_0z_0 dot x_0 dot y_0 dot z_0) in R^6","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"where","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"mboxSigm(x) = fracnu_max1 + e^r(v_0 - x)","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"and","category":"page"},{"location":"examples/jansen_rit/#","page":"Jansen-Rit model","title":"Jansen-Rit model","text":"C_1 = C quad C_2 = 08C quad C_4 = C_3 = 025C","category":"page"},{"location":"examples/lorenz96/#Lorenz-'96-system-1","page":"Lorenz96 system","title":"Lorenz '96 system","text":"","category":"section"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"dX_t = b_theta(X_t)dt + Sigma dW_tquad tin0Tquad X_0=x_0","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"where X and W are d-dimensional, Sigma is a d by d diagonal matrix and b is given by:","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"b^i_theta(x)= (x^i+1-x^i-2)x^i-1-x^i+theta","category":"page"},{"location":"examples/lorenz96/#","page":"Lorenz96 system","title":"Lorenz96 system","text":"where iin1dotsd is a cycling  index.","category":"page"},{"location":"#BridgeSDEInference.jl-1","page":"Home","title":"BridgeSDEInference.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"MCMC sampler for inference for diffusion processes with the use of Guided Proposals using the package Bridge.jl. Currently under development.","category":"page"},{"location":"#Problem-statements-1","page":"Home","title":"Problem statements","text":"","category":"section"},{"location":"#Partially-observed-diffusion-1","page":"Home","title":"Partially observed diffusion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Consider a stochastic process X, a solution to the stochastic differential equation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqmainSDE\nd X_t = b_theta(tX_t)dt + sigma_theta(tX_t)dW_tquad tin0Tquad X_0=x_0\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where b_thetaR^dto R^d is the drift function, sigma_thetaR^dto R^dtimes d is the volatility coefficient and W is a d-dimensional standard Brownian motion. We refer to X as a diffusion. thetain R^p is some unknown parameter. Suppose that a linearly transformed X, perturbed by Gaussian noise is observed at some collection of time points, i.e. that","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqpartObsData\nD=V_t_i i=1dots N\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"is observed for some t_i i=1dots N, where","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqpartialObservations\nV_t_i=L_i X_t_i + xi_i\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"with L_iin R^d_itimes d and independent xi_isim Gsn(0Sigma_i), (i=1dotsd). Suppose further that theta is equipped with some prior distribution pi(theta). The aim is to estimate the posterior distribution over theta, given the observation set D:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequationlabeleqposterior\npi(thetaD)propto pi(theta)pi(Dtheta)\nendequation","category":"page"},{"location":"#First-passage-time-observations-1","page":"Home","title":"First passage time observations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Consider a stochastic differential equation (\\ref{eq:mainSDE}) and suppose that the first coordinate of the drift term b_theta^1(tx)R^dto R is linear in x, whereas the first row of the volatility coefficient is identically equal to a zero vector sigma_theta^11d=0. Suppose further that instead of partial observation scheme as in (\\ref{eq:partObsData}), the process X is observed at a collection of stopping times:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"D=tau^star_i i=1dotsN","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where tau^star_i's are defined by","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginalign*\ntau_star0=0\ntau^star_i+1=inftgeq tau_stari X_t^1geq l^star_i+1quad i=0dots\ntau_stari=inftgeq tau^star_i X_t^1leq l_stariquad i=1dots\nendalign*","category":"page"},{"location":"#","page":"Home","title":"Home","text":"for some known constants l^star_i, l_stari, i=1dots. Note that tau^star_i's are the first passage times of the first coordinate process to some thresholds l^star_i, whereas tau_stari are the (latent) renewal times. The aim is to find a posterior (\\ref{eq:posterior}) from such first passage time data.","category":"page"},{"location":"#Mixed-effects-models-1","page":"Home","title":"Mixed-effects models","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Consider M stochastic differential equations","category":"page"},{"location":"#","page":"Home","title":"Home","text":"beginequation\nd X^(i)_t = b_thetaeta_i(tX^(i)_t)dt + sigma_thetaeta_i(tX^(i)_t)dW^(i)_tquad tin0Tquad X^(i)_0=x^(i)_0quad i=1dotsM\nendequation","category":"page"},{"location":"#","page":"Home","title":"Home","text":"where thetain R^p denotes the parameter that is shared among all of X^(i)'s, whereas eta_iin R^p_i, i=1dotsM are the parameters specific to a given X^(i). Suppose that the observations of the type (\\ref{eq:partObsData}) are given for each trajectory X^(i) (let's denote a joint set with D^star=cup_i=1^M D_i). The aim is to find the posterior:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"pi(thetaeta_ii=1dots MD^star)propto pi(theta)prod_i=1^Mpi(eta_i)pi(D_ithetaeta_i)","category":"page"},{"location":"#Overview-of-the-solutions-in-BridgeSDEInference.jl-1","page":"Home","title":"Overview of the solutions in BridgeSDEInference.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The first two problems from Overview of mathematical problems are addressed by the function","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mcmc","category":"page"},{"location":"#BridgeSDEInference.mcmc","page":"Home","title":"BridgeSDEInference.mcmc","text":"mcmc(setup)\n\nGibbs sampler alternately imputing unobserved parts of the path and updating unknown coordinates of the parameter vector. setup defines all variables of the Markov Chain\n\n\n\n\n\nmcmc(setups::Vector{<:MCMCSetup})\n\nGibbs sampler alternately imputing unobserved parts of the paths and updating unknown coordinates of the parameter vector. Version suitable for multiple trajectory samples. setups defines all variables required for the initialisation of the Markov Chain\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Home","title":"Home","text":"The third problem (Mixed-effects models) is addressed by the function (TODO fix so that points to a function in repeated.jl)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"mcmc","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Please see the Tutorial section to see how to appropriately initialise setup, run the mcmc function and query the results.","category":"page"},{"location":"#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"These are only the references which describe the algorithms implemented in this package. Note in particular that the list of references which treat the same problems as addressed by this package, but use methods which are not based on guided proposals is much, much longer. We refer to the bibliography sections of the papers listed below for references to other approaches.","category":"page"},{"location":"#Partial-observations-of-a-diffusion-1","page":"Home","title":"Partial observations of a diffusion","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Guided proposals for diffusion bridges (no-noise setting):\nMoritz Schauer, Frank van der Meulen, Harry van Zanten. Guided proposals for simulating multi-dimensional diffusion bridges. Bernoulli, 23(4A), 2017, pp. 2917–2950. [Bernoulli], [arXiv].\nBayesian inference with guided proposals for diffusions observed exactly and discretely in time:\nFrank van der Meulen, Moritz Schauer. Bayesian estimation of discretely observed multi-dimensional diffusion processes using guided proposals. Electronic Journal of Statistics 11 (1), 2017. [EJoS], [arXiv].\nBayesian inference with guided proposals for diffusions observed with noise (according to (\\ref{eq:partialObservations})):\nFrank van der Meulen, Moritz Schauer. Bayesian estimation of incompletely observed diffusions. Stochastics 90 (5), 2018, pp. 641–662. [Stochastics], [arXiv].\nSimulation of hypo-elliptic diffusion bridges:\nJoris Bierkens, Frank van der Meulen, Moritz Schauer. Simulation of elliptic and hypo-elliptic conditional diffusions. arXiv, 2018. [arXiv].\nEfficient schemes for computing all the necessary term for a fully generic implementation of guided proposals:\nFrank van der Meulen, Moritz Schauer. Continuous-discrete smoothing of diffusions. arXiv, 2017. [arXiv].","category":"page"},{"location":"#First-passage-time-set_observations-1","page":"Home","title":"First passage time set_observations","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"None published","category":"page"},{"location":"#Mixed-effect-models-1","page":"Home","title":"Mixed-effect models","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"None published","category":"page"},{"location":"man/generate_data/#Generation-of-data-1","page":"Data generation","title":"Generation of data","text":"","category":"section"},{"location":"man/generate_data/#","page":"Data generation","title":"Data generation","text":"There are three short scripts for generating data; they are available here. They illustrate how data can be generated in the setting of partially observed diffusion processes, first passage time observations as well as repeated observations (the last will soon be changed to mixed-effect models). In all three the main workhorse routine is simulateSegment, defined here (not part of the package, TODO maybe make it part of it). The FPT setting additionally uses findCrossings, defined in the same place.","category":"page"}]
}
