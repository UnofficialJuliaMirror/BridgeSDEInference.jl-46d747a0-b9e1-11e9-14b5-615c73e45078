
struct EmptyLadder end

struct BiasedPr{Tp,Tbp}
    prior::Tp
    bPrior::Tbp

    function BiasedPr(priors::Tp, bPriors::Tbp) where {Tp,Tbp}
        new{Tp, Tbp}(priors, bPriors)
    end
end

struct SimTempLadder{Tl,Tc,TP,TXX}
    Œ∫::Int64
    ladder::Tl
    c::Tc
    P::TP
    XX::TXX
    count::Array{Int64,2}
    accpt::Array{Int64,2}
    m::Int64

    function SimTempLadder(ladder::Tl, c::Tc, P::TP, XX::TXX
                           ) where {Tl,Tc,TP,TXX}
        Œ∫ = length(ladder)
        new{Tl,Tc,TP,TXX}(Œ∫, ladder, c, deepcopy(P), deepcopy(XX),
                          fill(0, (Œ∫, Œ∫)), fill(0, (Œ∫, Œ∫)), length(XX))
    end
end

struct SimTempPrLadder{Tl, Tc}
    Œ∫::Float64
    ladder::Tl
    c::Tc
    count::Array{Int64,2}
    accpt::Array{Int64,2}

    function SimTempPrLadder(ladder::Tl, c::Tc) where {Tl,Tc}
        Œ∫ = length(ladder)
        new{Tl,Tc}(Œ∫, ladder, c, fill(0, (Œ∫, Œ∫)), fill(0, (Œ∫, Œ∫)))
    end
end

struct ParTempLadder{Tl,TP,TXX}
    Œ∫::Float64
    ladder::Tl
    Ps::TP
    XXs::TXX
    count::Array{Int64,2}
    accpt::Array{Int64,2}
    m::Int64

    function ParTempLadder(ladder::Tl, Ps::TP, XXs::TXX) where {Tl,TP,TXX}
        Œ∫ = length(ladder)
        new{Tl,TP,TXX}(Œ∫, ladder, deepcopy(Ps), deepcopy(XXs),
                       fill(0, (Œ∫, Œ∫)), fill(0, (Œ∫, Œ∫)), length(XXs[1]))
    end
end

struct ParTempPrLadder{Tl}
    Œ∫::Float64
    ladder::Tl
    count::Array{Int64,2}
    accpt::Array{Int64,2}

    function ParTempPrLadder(ladder::Tl) where Tl
        Œ∫ = length(ladder)
        new{Tl}(Œ∫, ladder, fill(0, (Œ∫, Œ∫)), fill(0, (Œ∫, Œ∫)))
    end
end

Ladders = Union{SimTempLadder,ParTempLadder,SimTempPrLadder,ParTempPrLadder}
Nonùì£Ladders = Union{EmptyLadder,BiasedPr,SimTempPrLadder,ParTempPrLadder}
ùì£Ladders = Union{SimTempLadder,ParTempLadder}
SimLadders = Union{SimTempLadder,SimTempPrLadder}

accptRate(::T) where T = NaN
accptRate(‚Ñí::T) where T <: Ladders = ‚Ñí.accpt ./ ‚Ñí.count

ùì£ladder(::T, i) where T <: Nonùì£Ladders = NaN
ùì£ladder(‚Ñí::T, i) where T <: ùì£Ladders = ‚Ñí.ladder[i]

function llikelihood!(‚Ñí::T, Œ∏, y, WW, P, XX, Œπ, ::ST=Ralston3()
                      ) where {T <: ùì£Ladders, ST}
    for i in 1:‚Ñí.m
        P[i] = GuidPropBridge(P[i], Œ∏, ‚Ñí.ladder[Œπ])
    end
    solveBackRec!(‚Ñí.P, ST())
    y‚ÇÄ = copy(y)
    for i in 1:m
        solve!(Euler(), XX[i], y‚ÇÄ, WW[i], P[i])
        y‚ÇÄ = XX[i].yy[end]
    end
    ll·µí = 0.0
    for i in 1:m
        ll·µí += llikelihood(LeftRule(), XX[i], P[i])
    end
    ll·µí
end

function computeLogWeight!(‚Ñí::BiasedPr, Œ∏)
    logWeight = 0.0
    for (prior, bprior) in zip(‚Ñí.prior, ‚Ñí.bPrior)
        logWeight = logpdf(prior, Œ∏) - logpdf(bprior, Œ∏)
    end
    logWeight
end

function computeLogWeight!(‚Ñí::SimTempLadder, Œ∏, y, WW, Œπ, ll, ::ST=Ralston3()) where ST
    Œπ == 1 && return 0.0
    ll‚ÇÅ = llikelihood!(‚Ñí, Œ∏, y, WW, ‚Ñí.P, ‚Ñí.XX, 1, ST())
    ll‚ÇÅ - ll
end

function computeLogWeight(‚Ñí::SimTempPrLadder, Œ∏, Œπ)
    Œπ == 1 && return 0.0
    logWeight = 0.0
    for (prior, prior·µí) in zip(‚Ñí.ladder[1], ‚Ñí.ladder[Œπ])
        logWeight = logpdf(prior, Œ∏) - logpdf(prior·µí, Œ∏)
    end
    logWeight
end

function computeLogWeight!(‚Ñí::ParTempLadder, Œ∏, y, WW, Œπ, idx, ll, ::ST=Ralston3()) where ST
    Œπ == 1 && return 0.0
    ll‚ÇÅ = llikelihood!(‚Ñí, Œ∏, y, WW, ‚Ñí.Ps[idx], ‚Ñí.XXs[idx], 1, ST())
    ll‚ÇÅ - ll
end

function computeLogWeight(‚Ñí::ParTempPrLadder, Œ∏s, Œπ, idx)
    idx == 1 && return 0.0
    logWeight = 0.0
    for (prior, prior·µí) in zip(‚Ñí.ladder[1], ‚Ñí.ladder[idx])
        logWeight = logpdf(prior, Œ∏s[Œπ[idx]]) - logpdf(prior·µí, Œ∏s[Œπ[idx]])
    end
    logWeight
end

function update!(‚Ñí::SimTempLadder, Œ∏, y, WW, Œπ, ll, ::ST=Ralston3();
                 verbose=false, it=NaN) where ST
    Œπ·µí = rand([max(Œπ-1, 1), min(Œπ+1, ‚Ñí.Œ∫)])
    ‚Ñí.count[Œπ, Œπ·µí] += 1
    if Œπ·µí == Œπ
        llr = 0.0
    else
        ll·µí = llikelihood!(‚Ñí, Œ∏, y, WW, Œπ·µí, ST())
        llr = ll·µí + log(‚Ñí.c[Œπ·µí]) - ll - log(‚Ñí.c[Œπ])
    end
    verbose && print("prior index update: ", it, " diff_ll: ",
                     round(llr, digits=3))
    if acceptSample(llr, verbose)
        ‚Ñí.accpt[Œπ, Œπ·µí] += 1
        return Œπ·µí
    else
        return Œπ
    end
end

function update!(‚Ñí::SimTempPrLadder, Œ∏, Œπ, ::ST=Ralston3(); verbose=false,
                 it=NaN) where ST
    Œπ·µí = rand([max(Œπ-1, 1), min(Œπ+1, Œ∫)])
    ‚Ñí.count[Œπ, Œπ·µí] += 1
    if Œπ·µí == Œπ
        llr = 0.0
    else
        llr = log(‚Ñí.c[Œπ·µí]) - log(‚Ñí.c[Œπ])
        for (prior, prior·µí) in zip(‚Ñí.ladder[Œπ], ‚Ñí.ladder[Œπ·µí])
            llr += logpdf(prior·µí, Œ∏) - logpdf(prior, Œ∏)
        end
    end
    verbose && print("prior index update: ", it, " diff_ll: ",
                     round(llr, digits=3))
    if acceptSample(llr, verbose)
        ‚Ñí.accpt[Œπ, Œπ·µí] += 1
        return Œπ·µí
    else
        return Œπ
    end
end

function update!(‚Ñí::ParTempLadder, Œ∏s, ys, WWs, Œπ, lls, ::ST=Ralston3();
                 verbose=false, it=NaN) where ST
    idx = rand(1:length(Œπ)-1)
    Œπ·µí = copy(Œπ)
    Œπ·µí[idx], Œπ·µí[idx+1] = Œπ·µí[idx+1], Œπ·µí[idx]
    ‚Ñí.count[idx, idx+1] += 1
    ll·µí = ( llikelihood!(‚Ñí, Œ∏s[Œπ·µí[idx]], ys[Œπ·µí[idx]], WWs[Œπ·µí[idx]], idx, ST())
            + llikelihood!(‚Ñí, Œ∏s[Œπ·µí[idx]+1], ys[Œπ·µí[idx]], WWs[Œπ·µí[idx]+1], idx+1,
                           ST()) )
    llr = ll·µí - lls[idx] - lls[idx+1]

    verbose && print("prior index update: ", it, " diff_ll: ",
                     round(llr, digits=3))
    if acceptSample(llr, verbose)
        ‚Ñí.accpt[idx, idx+1] += 1
        return Œπ·µí
    else
        return Œπ
    end
end

function update!(‚Ñí::SimTempPrLadder, Œ∏s, Œπ, ::ST=Ralston3(); verbose=false,
                 it=NaN) where ST
    idx = rand(1:length(Œπ)-1)
    Œπ·µí = copy(Œπ)
    Œπ·µí[idx], Œπ·µí[idx+1] = Œπ·µí[idx+1], Œπ·µí[idx]

    ‚Ñí.count[idx, idx+1] += 1
    llr = 0.0
    for (prior, priorNext) in zip(‚Ñí.ladder[idx], ‚Ñí.ladder[idx+1])
        llr += ( logpdf(prior, Œ∏s[Œπ·µí[idx]]) + logpdf(priorNext, Œ∏s[Œπ·µí[idx]+1])
                 - logpdf(prior, Œ∏s[Œπ[idx]]) + logpdf(priorNext, Œ∏s[Œπ[idx]+1]) )
    end

    verbose && print("prior index update: ", it, " diff_ll: ",
                     round(llr, digits=3))
    if acceptSample(llr, verbose)
        ‚Ñí.accpt[idx, idx+1] += 1
        return Œπ·µí
    else
        return Œπ
    end
end
